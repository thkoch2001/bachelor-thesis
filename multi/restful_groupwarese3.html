<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Media Types</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,2 --> 
<meta name="src" content="restful_groupware.tex"> 
<meta name="date" content="2012-02-14 12:24:00"> 
<link rel="stylesheet" type="text/css" href="restful_groupware.css"> 
</head><body 
>
    <!--l. 278--><div class="crosslinks"><p class="noindent">[<a 
href="restful_groupwarese17.html" >next</a>] [<a 
href="restful_groupwarese2.html" >prev</a>] [<a 
href="restful_groupwarese2.html#tailrestful_groupwarese2.html" >prev-tail</a>] [<a 
href="#tailrestful_groupwarese3.html">tail</a>] [<a 
href="restful_groupware.html#restful_groupwarese8.html" >up</a>] </p></div>
    <h3 class="sectionHead"><span class="titlemark">3.  </span> <a 
 id="x10-230003"></a>Media Types</h3>
<!--l. 285--><p class="noindent" >
      <div class="quote">
      <!--l. 286--><p class="noindent" >To some extent, people get REST wrong because I failed to include enough detail
      on media type design within my dissertation.&#x00A0;&#8211;&#x00A0;Roy T. Fielding</div>
<!--l. 289--><p class="noindent" >from: Rest APIs must be hypertext driven<span class="footnote-mark"><a 
href="restful_groupware11.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x10-23001f6"></a> 
<!--l. 292--><p class="indent" >    <span class="cite">[<a 
href="restful_groupwareli2.html#XPautasso:2008:RWS:1367497.1367606">PZL08</a>, sec. 7.2]</span> identifies the support of different media types as an issue that &#8221;can
complicate and hinder the interoperability&#8221; and &#8221;requires more maintenance effort&#8221;.
<!--l. 294--><p class="indent" >    <span class="cite">[<a 
href="restful_groupwareli2.html#XDavis:2011:XTR:1967428.1967437">DM11</a>]</span> proposes a XML based REST framework that uses XForms, XQuery, XProc, XSLT
and an XML database. It can benefit from the constraint that it only supports XML based media
types. It is to be seen, which ideas from this work could be reused in the case of a broader variety
of supported media types.
<!--l. 296--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.1.  </span> <a 
 id="x10-240003.1"></a>Syntax vs. Semantic</h4>
<!--l. 298--><p class="noindent" >The usage of standardized media types is one key difference between an API and a
restful API. <span class="cite">[<a 
href="restful_groupwareli2.html#XFielding2000">Fie00</a>, sec. 5.2.1.2]</span> Only if the client has knowledge about the media
type can it do something meaningful with it besides just receiving it. In that sense,
the often used mime types application/xml or application/json are not really media
types. They don&#8217;t tell the browser or user anything meaningful beside the <span 
class="cmti-12">syntax </span>of the
data.<span class="footnote-mark"><a 
href="restful_groupware12.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x10-24001f7"></a> 
<!--l. 308--><p class="indent" >    To do anything meaningful with plain json or xml, the client programmer must normally look
up the meaning or <span 
class="cmti-12">semantic </span>of the data in the API documentation. The data therefor fails the
self-descriptive constraint of REST.
<!--l. 313--><p class="indent" >    Compare this with a mime type like <span 
class="cmtt-12">application/atom+xml</span>. It specifies the syntax (xml) and
the semantic (atom) of the data. Of course somebody once needed to read the atom specification
and program the client with the knowledge of how to process this media type. The purpose of
standardized media types however is that there is a limited number of them and that they are
reused by many sites and clients.
<!--l. 320--><p class="indent" >    Large sites like Google, Facebook or Twitter can successfully attract enough developers to read
their specifications and program clients accordingly. Usually one can also find client libraries that
can help a lot. REST however envisions a decentralized web in which parties can interact without
previous knowledge of each other. This becomes possible through the usage of well known
predefined media types.
                                                                                         
                                                                                         
<!--l. 336--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.2.  </span> <a 
 id="x10-250003.2"></a>Data Models of Media Types</h4>
<!--l. 338--><p class="noindent" >TODO:
      <ul class="itemize1">
      <li class="itemize">Ein generelles Daten Modell wäre hilfreich, um alle Medien Typen darauf zu projezieren
      und mit einer solchen Projektion dann innerhalb der Applikation zu arbeiten
      </li>
      <li class="itemize">Ein  allgemeines  Datenmodell  könnte  auch  eine  Hilfe  sein  als  Zwischenschritt  für
      Conversions zwischen Medientypen
      </li>
      <li class="itemize">Es gibt kein allgemeines, sinnvolles Datenmodell für alle Medientypen
      </li>
      <li class="itemize">Trotzdem können bestimmte hilfreiche Generalisierungen vorgenommen werden
           <ul class="itemize2">
           <li class="itemize">Die meisten Resourcen haben bestimmte generische Metadaten die entweder im
           Medientyp kodiert werden können oder mit dem Medientyp zusammen persistiert
           werden müssen
           </li>
           <li class="itemize">Diese Metadaten finden sich auch in atom:entry wieder und sind: Autor, Updated,
           Titel, Summary, etag, id, name, links
           </li>
           <li class="itemize">Transitional               Links               vs               Structural               Links:
           <a 
href="http://java.net/projects/jax-rs-spec/pages/Hypermedia" class="url" ><span 
class="cmtt-12">http://java.net/projects/jax-rs-spec/pages/Hypermedia</span></a>
           </li>
           <li class="itemize">Different categories of data: CSV, binary/plain text, large binary (video), tree
           (XML/JSON) (Referenz?)
           </li></ul>
      </li></ul>
<!--l. 354--><p class="noindent" >
    <h5 class="subsubsectionHead"><span class="titlemark">3.2.1.  </span> <a 
 id="x10-260003.2.1"></a>XML vs. JSON</h5>
<!--l. 356--><p class="noindent" >This section investigates the two most common data models used by media types and the issues
that arise if an application needs to support both of them.
<!--l. 359--><p class="indent" >    The application section of the IANA mime type registration has 294 entries ending in &#8220;+xml&#8221; and only 3
ending in &#8220;+json&#8221;.<span class="footnote-mark"><a 
href="restful_groupware13.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x10-26001f8"></a> 
This stands in contrast to the rise of public JSON APIs and the decline of XML
APIs.<span class="footnote-mark"><a 
href="restful_groupware14.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x10-26002f9"></a> 
                                                                                         
                                                                                         
<!--l. 365--><p class="indent" >    Web developers often prefer JSON over XML because it is perceived as easier to parse, process and
smaller in size. XML in comparison is seen as complicate, slow to process and larger in size. A strong
argument for JSON as the preferred format for JavaScript applications is that JSON is a subset of
JavaScript.<span class="footnote-mark"><a 
href="restful_groupware15.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x10-26003f10"></a> 
<!--l. 373--><p class="indent" >    A drawback of this mismatch between the preference of media type designers and API
consumers is a possible duplication of work and incompatibilities across different APIs. If two
developers independently take the same XML media type as a model to develop a JSON format,
they can still come up with different results. There is no standard mapping from XML schemes to
JSON structures.
<!--l. 379--><p class="indent" >    Instead, possible mappings have to trade of the preservation of all structural information
against the &#8220;friendliness&#8221; of the resulting JSON structure.<span class="cite">[<a 
href="restful_groupwareli2.html#XBoyer2011">BGM<sup><span 
class="cmr-8">+</span></sup>11</a>]</span> Without going into detail, a
JSON structure can be seen as friendly if it makes best use of JSON&#8217;s data types, is compact and
easy to process. <span 
class="cmbx-12">??</span> shows two different examples how to map data from XML to JSON with
one of them using JSON number values, being more compact and probably easier to
process.
<!--l. 410--><p class="indent" >    Activity Streams has avoided the misalignment of an official XML format and an
unofficial JSON deviate by defining an XML (ATOM) and JSON format from the
beginning.<span class="footnote-mark"><a 
href="restful_groupware16.html#fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
 id="x10-26004f11"></a> 
<!--l. 412--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.3.  </span> <a 
 id="x10-270003.3"></a>vCard, iCalendar, xCard and xCal</h4>
<!--l. 414--><p class="noindent" >TODO:
      <ul class="itemize1">
      <li class="itemize">Textbasierte vs. XML Formate</li></ul>
<!--l. 419--><p class="indent" >    Version 3 of vCard was published in 1998<span class="cite">[<a 
href="restful_groupwareli2.html#XRFC2425">HSD98</a>]</span> only a few months after the W3C
published Version 1.0 of XML<span class="cite">[<a 
href="restful_groupwareli2.html#XPaoli:98:XR">PSMB98</a>]</span> and eight years before JSON became an official
standard.<span class="cite">[<a 
href="restful_groupwareli2.html#XRFC4627">Cro06</a>]</span>
<!--l. 423--><p class="noindent" >
    <h5 class="subsubsectionHead"><span class="titlemark">3.3.1.  </span> <a 
 id="x10-280003.3.1"></a>Hypermedia Support</h5>
<!--l. 425--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x10-280011"></a>
                                                                                         
                                                                                         
<!--l. 447--><p class="noindent" >                                ServiceDoc<!--l. 430--><p class="noindent" >Contacts
Collectionnext<!--l. 434--><p class="noindent" >Calendar
CollectionEntry (xCard)1..n<!--l. 439--><p class="noindent" >personal
calendarrelated xCardsEntry (xCal event)1..nparticipants
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;1: </span><span  
class="content">Hypermedia support in xCard and xCal</span></div><!--tex4ht:label?: x10-280011 -->
                                                                                         
                                                                                         
<!--l. 449--><p class="noindent" ></div><hr class="endfigure">
<!--l. 451--><p class="indent" >    The iCalendar standard defines a several properties that can link to external representations of
the properties value by specifying an &#8220;Alternate Text Representation&#8221; parameter. These are
comment, summary, description, contact, location, resources. The properties attendee and
organizer can have a &#8220;Directory Entry Reference&#8221; parameter that should contain an URI to a
person resource. One property that can not be dereferenced is &#8220;Related To&#8221;: It only contains the
globally unique identifier of another calendar component.
<!--l. 459--><p class="indent" >    One problem that arises with the use of hyperlinks in personal information management is
identification across administrative boundaries. Take for example an event that gets sent from one
organization to another and contains hyperlinks to person representations. These hyperlinks most
likely point to an internal addressbook of the organization and may not be accessible by the
receiver of the event information. The receiver however may have his own addressbook containing
information about the person.
    <h4 class="subsectionHead"><span class="titlemark">3.4.  </span> <a 
 id="x10-290003.4"></a>Derived JSON formats for PIM data</h4>
<!--l. 469--><p class="noindent" >TODO Übereinstimmungen und Unterschiede vCard, portable contacts: Which fields of portable
contacts are derived from vCard: <a 
href="http://wiki.portablecontacts.net/w/page/17776141/schema" class="url" ><span 
class="cmtt-12">http://wiki.portablecontacts.net/w/page/17776141/schema</span></a>
<!--l. 471--><p class="indent" >    Calendar Formate nur kurz
<!--l. 473--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.5.  </span> <a 
 id="x10-300003.5"></a>Microdata</h4>
<!--l. 475--><p class="noindent" >TODO Microformats could also be useful to markup data elements in a (X)HTML summmary of
an Atom entry. In this case a web client could use the data from the summary in a tabular
view without fetching the full enclosed data in case it is not contained in the content
tag.
<!--l. 481--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.6.  </span> <a 
 id="x10-310003.6"></a>Media Types for Collections</h4>
<!--l. 483--><p class="noindent" >Vergleich ATOM mit Medientyp Collection+JSON
<!--l. 485--><p class="indent" >    JSON formats for collections: Collection+JSON Mime-Type (approved in July 2011) by Mike
Amundsen<span class="footnote-mark"><a 
href="restful_groupware17.html#fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
 id="x10-31001f12"></a> 
JSON ATOM serialization implemented by Apache
Abdera<span class="footnote-mark"><a 
href="restful_groupware18.html#fn13x0"><sup class="textsuperscript">13</sup></a></span><a 
 id="x10-31002f13"></a> 
<!--l. 490--><p class="indent" >    Some problems in loss-less conversion of ATOM to json:<span class="cite">[<a 
href="restful_groupwareli2.html#XSnell2008">Sne08</a>]</span>
      <ul class="itemize1">
      <li class="itemize">JSON has no equivalent for the xml:lang attribute.
      </li>
      <li class="itemize">Dereferencable IRIs must be transformed to URIs.
                                                                                         
                                                                                         
      </li>
      <li class="itemize">URIs relative to an xml:base attribute must be resolved, also inside XHTML content
      elements.
      </li>
      <li class="itemize">Repeatable elements must be converted to arrays.
      </li>
      <li class="itemize">The ATOM date format (RFC 3339) differs from the JavaScript Date serialization.
      </li>
      <li class="itemize">ATOM content elements are versatile but should be represented more meaningful in
      JSON then just a plain String.
      </li>
      <li class="itemize">ATOM supports arbitrary extensions via namespaces.</li></ul>
<!--l. 501--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.7.  </span> <a 
 id="x10-320003.7"></a>Media Type conversion</h4>
<!--l. 503--><p class="noindent" >Konvertieren zwischen verschiedenen Representationen die nach aussen gegeben werden vs.
Konvertieren zwischen äußerer Representation und Representation für die Datenbank.
<!--l. 505--><p class="indent" >    An welchen Punkten in der Architektur muss/kann/soll konvertiert werden?
<!--l. 507--><p class="noindent" >
    <h4 class="subsectionHead"><span class="titlemark">3.8.  </span> <a 
 id="x10-330003.8"></a>Updates with non isomorphic Media Types</h4>
<!--l. 508--><p class="noindent" >How to handle updates, if the mediatypes are not isomorph?
<!--l. 510--><p class="indent" >    How does Google handle PATCH in the calendar API?
<!--l. 512--><p class="indent" >    Schnittmenge der Medientypen identifizieren
<!--l. 514--><p class="indent" >    Einen kanonischen Medientypen festlegen für Updates?
<!--l. 516--><p class="indent" >    Erweiterungsmöglichkeiten v. Medientypen nutzen um Isomorphie herzustellen
                                                                                         
                                                                                         
    <!--l. 519--><div class="crosslinks"><p class="noindent">[<a 
href="restful_groupwarese17.html" >next</a>] [<a 
href="restful_groupwarese2.html" >prev</a>] [<a 
href="restful_groupwarese2.html#tailrestful_groupwarese2.html" >prev-tail</a>] [<a 
href="restful_groupwarese3.html" >front</a>] [<a 
href="restful_groupware.html#restful_groupwarese8.html" >up</a>] </p></div>
<!--l. 519--><p class="indent" >    <a 
 id="tailrestful_groupwarese3.html"></a>   
</body></html> 
